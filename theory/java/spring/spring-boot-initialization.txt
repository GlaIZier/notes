When Spring boot works there is no context yet. Spring context initialization (factorybean, beanpostprocessor...) works after spring boot.

Spring boot is responsible for: dependencies, configs and deployment and startup.

Dependencies: use spring boot parent, which includes parent with dependencies and versions in dependencyManagement block in pom to point out the exact version. But in this case we can't use our own parent pom. To be able to do it we can use bom with dependencies. The same for gradle.

The start of Spring application is the context creation (web.xml -> listeners ...).
In Spring Boot context is created like this: ApplicationContext = context = SpringApplication.run(App.class, args); Instead of App.class we can use context.xml, script.groove or some others.

SpringApplication creates context (it knows the exact type of context it needs to create: ClasspathXmlApplicationContext, Annotation...). Also, it deduce which context it needs to create WebContext (if there is servlet.class ... in classpath) or GenericContext (desktop app). After the context is created it contains lots of infrastructal beans: datasource... and many others that came from starters. 

To be able to add some our custom infrastructure we need to create some our configuration with beans and either: create @EnableOurConfig which will do @Import(MyConfig.class), 
either:
we will create at the same place with logic of configuration in resources/META-INF/spring.factories: starter: value1, value2 (EnableAutoConfiguration=com.our.MyConfig). SpringBoot will use our spring.factories then. @SpingBootApplication includes @ComponentScan, @Configuration, @EnableAutoConfiguration

@EnableAutoConfiguration: annotated with @Import({EnableAutoConfigurationImportSelector.class}). After SpringBoot release it becomes possible to @Import selectors and registrars (in runtime will add some beanDefinitions), not only configurations. 

EnableAutoConfigurationImportSelector: scans all spring.factories with "EnableAutoConfiguration="  and, hence, configurations and, hence, beans (dataSource...). This selector uses SpringFactoriesLoader to find all spring facrories by using: static List<String> loadFactoryNames(Class<?> factoryClass, ClassLoader classLoader). factoryclass.getName will be used for search in spring.factoies (eg factoryclass.getName = EnableAutoConfiguration). Starters use this mechanism. 

Also, spring-boot-autoconfigure.jar has its own spring.factories that includes a very long sequence of configurations: AopAutoConfiguration, RabbitAutoConfiguration... Additionally, CacheAutoConfiguration includes hard-coded mappings with classes by importing @Import(CacheConfigurationImportSelector.class) which scans special static file CacheConfiguration with many different configurations. This was done for users' convenience. If it wasn't like that, you would need to download not only the dependency from maven, but also the starter for this particular version of dependency. In the hard-coded way you just need to download the dependency. A starter is merged into Spring Boot itself.
